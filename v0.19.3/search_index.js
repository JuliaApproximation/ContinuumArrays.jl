var documenterSearchIndex = {"docs":
[{"location":"#ContinuumArrays.jl","page":"Home","title":"ContinuumArrays.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for working with bases as quasi-arrays","category":"page"},{"location":"#The-Basis-interface","page":"Home","title":"The Basis interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To add your own bases, subtype Basis and overload the following routines:","category":"page"},{"location":"","page":"Home","title":"Home","text":"axes(::MyBasis) = (Inclusion(mydomain), OneTo(mylength))\ngrid(::MyBasis, ::Integer)\ngetindex(::MyBasis, x, ::Integer)\n==(::MyBasis, ::MyBasis)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Optional overloads are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"plan_transform(::MyBasis, sizes::NTuple{N,Int}, region) to plan a transform, for a tensor","category":"page"},{"location":"","page":"Home","title":"Home","text":"product of the specified sizes, similar to plan_fft.","category":"page"},{"location":"","page":"Home","title":"Home","text":"diff(::MyBasis, dims=1) to support differentiation and Derivative. \ngrammatrix(::MyBasis) to support Q'Q. \nContinuumArrays._sum(::MyBasis, dims) and ContinuumArrays._cumsum(::MyBasis, dims) to support definite and indefinite integeration.\nplotgrid(::MyBasis, n...): return n grid points suitable for plotting the basis. The default value for n is 10,000. ","category":"page"},{"location":"#Differential-Operators","page":"Home","title":"Differential Operators","text":"","category":"section"},{"location":"#ContinuumArrays.Derivative","page":"Home","title":"ContinuumArrays.Derivative","text":"Derivative(axis)\n\nrepresents the differentiation (or finite-differences) operator on the specified axis.\n\n\n\n\n\n","category":"type"},{"location":"#ContinuumArrays.Laplacian","page":"Home","title":"ContinuumArrays.Laplacian","text":"Laplacian(axis)\n\nrepresents the laplacian operator Δ on the specified axis.\n\n\n\n\n\n","category":"type"},{"location":"#ContinuumArrays.AbsLaplacian","page":"Home","title":"ContinuumArrays.AbsLaplacian","text":"AbsLaplacian(axis)\n\nrepresents the positive-definite/negative/absolute-value laplacian operator |Δ| ≡ -Δ on the specified axis.\n\n\n\n\n\n","category":"type"},{"location":"#ContinuumArrays.laplacian","page":"Home","title":"ContinuumArrays.laplacian","text":"abslaplacian(A, k=1)\n\ncomputes Δ^k * A. \n\n\n\n\n\n","category":"function"},{"location":"#ContinuumArrays.abslaplacian","page":"Home","title":"ContinuumArrays.abslaplacian","text":"abslaplacian(A, α=1)\n\ncomputes Δ^α * A. \n\n\n\n\n\n","category":"function"},{"location":"#ContinuumArrays.weaklaplacian","page":"Home","title":"ContinuumArrays.weaklaplacian","text":"weaklaplacian(A)\n\nrepresents the weak Laplacian.\n\n\n\n\n\n","category":"function"},{"location":"#Routines","page":"Home","title":"Routines","text":"","category":"section"},{"location":"#ContinuumArrays.transform","page":"Home","title":"ContinuumArrays.transform","text":"transform(A, f)\n\nfinds the coefficients of a function f expanded in a basis defined as the columns of a quasi matrix A. It is equivalent to\n\nA \\ f.(axes(A,1))\n\n\n\n\n\n","category":"function"},{"location":"#ContinuumArrays.expand","page":"Home","title":"ContinuumArrays.expand","text":"expand(A, f)\n\nexpands a function f im a basis defined as the columns of a quasi matrix A. It is equivalent to\n\nA / A \\ f.(axes(A,1))\n\n\n\n\n\nexpand(v)\n\nfinds a natural basis for a quasi-vector and expands in that basis.\n\n\n\n\n\n","category":"function"},{"location":"#ContinuumArrays.grid","page":"Home","title":"ContinuumArrays.grid","text":"grid(P, n...)\n\nCreates a grid of points. if n is unspecified it will be sufficient number of points to determine size(P,2) coefficients. If n is an integer or Block its enough points to determine n coefficients. If n is a tuple then it returns a tuple of grids corresponding to a tensor-product. That is, a 5⨱6 2D transform would be\n\n(x,y) = grid(P, (5,6))\nplan_transform(P, (5,6)) * f.(x, y')\n\nand a 5×6×7 3D transform would be\n\n(x,y,z) = grid(P, (5,6,7))\nplan_transform(P, (5,6,7)) * f.(x, y', reshape(z,1,1,:))\n\n\n\n\n\n","category":"function"},{"location":"#ContinuumArrays.plotgrid","page":"Home","title":"ContinuumArrays.plotgrid","text":"plotgrid(P, n...)\n\nreturns a grid of points suitable for plotting. This may include endpoints or singular points not included in grid. n specifies the number of coefficients.\n\n\n\n\n\n","category":"function"},{"location":"#Interal-Routines","page":"Home","title":"Interal Routines","text":"","category":"section"},{"location":"#ContinuumArrays.TransformFactorization","page":"Home","title":"ContinuumArrays.TransformFactorization","text":"TransformFactorization(grid, plan)\n\nassociates a planned transform with a grid. That is, if F is a TransformFactorization, then F \\ f is equivalent to F.plan * f[F.grid].\n\n\n\n\n\n","category":"type"},{"location":"#ContinuumArrays.AbstractConcatBasis","page":"Home","title":"ContinuumArrays.AbstractConcatBasis","text":"AbstractConcatBasis\n\nis an abstract type representing a block diagonal basis but with modified axes.\n\n\n\n\n\n","category":"type"},{"location":"#ContinuumArrays.MulPlan","page":"Home","title":"ContinuumArrays.MulPlan","text":"MulPlan(matrix, dims)\n\nTakes a matrix and supports it applied to different dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#ContinuumArrays.PiecewiseBasis","page":"Home","title":"ContinuumArrays.PiecewiseBasis","text":"PiecewiseBasis(args...)\n\nis an analogue of Basis that takes the union of the first axis, and the second axis is a blocked concatenatation of args. If there is overlap, it uses the first in order.\n\n\n\n\n\n","category":"type"},{"location":"#ContinuumArrays.Map","page":"Home","title":"ContinuumArrays.Map","text":"A subtype of Map is used as a one-to-one map between two domains via view. The domain of the map m is axes(m,1) and the range is union(m).\n\nMaps must also overload invmap to give the inverse of the map, which is equivalent to invmap(m)[x] == findfirst(isequal(x), m).\n\n\n\n\n\n","category":"type"},{"location":"#ContinuumArrays.MappedFactorization","page":"Home","title":"ContinuumArrays.MappedFactorization","text":"MappedFactorization(F, map)\n\nremaps a factorization to a different domain. That is, if M is a MappedFactorization then M \\ f is equivalent to F \\ f[map]\n\n\n\n\n\n","category":"type"},{"location":"#ContinuumArrays.basis","page":"Home","title":"ContinuumArrays.basis","text":"basis(v)\n\ngives a basis for expanding given quasi-vector.\n\n\n\n\n\n","category":"function"},{"location":"#ContinuumArrays.InvPlan","page":"Home","title":"ContinuumArrays.InvPlan","text":"InvPlan(factorization, dims)\n\nTakes a factorization and supports it applied to different dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#ContinuumArrays.VcatBasis","page":"Home","title":"ContinuumArrays.VcatBasis","text":"VcatBasis\n\nis an analogue of Basis that vcats the values.\n\n\n\n\n\n","category":"type"},{"location":"#ContinuumArrays.WeightedFactorization","page":"Home","title":"ContinuumArrays.WeightedFactorization","text":"WeightedFactorization(w, F)\n\nweights a factorization F by w.\n\n\n\n\n\n","category":"type"},{"location":"#ContinuumArrays.HvcatBasis","page":"Home","title":"ContinuumArrays.HvcatBasis","text":"VcatBasis\n\nis an analogue of Basis that hvcats the values, so they are matrix valued.\n\n\n\n\n\n","category":"type"},{"location":"#ContinuumArrays.ProjectionFactorization","page":"Home","title":"ContinuumArrays.ProjectionFactorization","text":"ProjectionFactorization(F, inds)\n\nprojects a factorization to a subset of coefficients. That is, if P is a ProjectionFactorization then P \\ f is equivalent to (F \\ f)[inds]\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"```","category":"page"}]
}
